# Creating CSV files that make life easier

Often the data files in `.csv` format need to be processed in two steps
1. Read the data
2. Post-process the data into the desired format

One of the most common post-processing steps is to convert a numeric column into a factor.

It is easy to avoid the need to do this if the columns representing factors are not stored as integers.

## Convert integers to strings with a tag

For this illustration we first install the environment
```julia
using DrWatson
@quickactivate "SMLP2020"
using CSV, DataFrames
```

I typically define a function like
```julia
function stringify(x::Vector{<:Integer}, tag='S')
    strgs = string.(x)
    string.(tag, lpad.(strgs, maximum(length.(strgs)), '0'))
end
```

(At the end of this document I will give the details of the operations in this function, for those who are interested.)

Suppose we read a file like
```julia
df = DataFrame(CSV.File(datadir("chr_data.csv")));
describe(df)
```

Now, change the `Subject` and `Item` columns to strings
```julia 
transform!(df, :Subject => stringify => :Subject);
transform!(df, :Item => (x -> stringify(x, 'I')) => :Item);
describe(df)
```

Writing the data frame as a CSV file and reading it back in results in string values for the `Subject` and `Item` columns.
```julia
CSV.write(datadir("chr_data1.csv"), df);
df1 = DataFrame(CSV.File(datadir("chr_data1.csv"), pool=true));
describe(df1)
```

The element types of the `Subject` and `Item` columns are `String` but the columns themselves are stored as `PooledArray`s.
```julia
typeof(df1.Subject)
```

## Categorical covariates

For these data I would probably also change the `Accuracy` column to a categorical factor.
Right now there is some discussion in the Julia data science community on the `CategoricalArrays` package so I would use `PooledArrays` instead.

```julia
using PooledArrays
df.Accuracy = PooledArray(ifelse.(iszero.(df.Accuracy), "N", "Y"));
typeof(df.Accuracy)
```

## stringify in detail

The code for the `stringify` function
```
function stringify(x::Vector{<:Integer}, tag='S')
    strgs = string.(x)
    string.(tag, lpad.(strgs, maximum(length.(strgs)), '0'))
end
```
declares the argument `x` to be a `Vector` (i.e. one-dimensional `Array`) of any type that is a subtype of `Integer`.
This includes several concrete types.
```julia
subtypes(Integer)
```
```julia
subtypes(Signed)
```

The `tag` argument is given a default value of `'S'` but no specific type.  Any type to which `string` can apply will work here.

The first line
```
strngs = string.(x)
```
converts the integer values in `x` to a vector of strings and assigns this to the name `strngs`.
The dot after `string` indicates that the `string` function is to be applied element-wise to the vector `x`, producing a vector of strings.
This is called `dot-broadcasting` or [`dot-vectorization`](https://docs.julialang.org/en/v1/manual/functions/#man-vectorized)

The next line
```
string.(tag, lpad.(strgs, maximum(length.(strgs)), '0'))
```
is where all the action takes place.
Each element of the `strngs` vector is padded on the left (`lpad`) with `'0'` characters to bring it to the length of the longest string, then the `tag` is prepended.

# Appendix

## Output options
This script can be used to generate alternative source or output files in the REPL.

**Alternative source files**
```
julia> using Weave
julia> convert_doc("*.jmd", "*.ipynb")  # input for Jupyter notebook
julia> convert_doc("*.jmd", "*.jl")     # Julia script w/o markdown
```
**Alternative output files**

The script can be executed and the output written with different formats. The first command lists all options. The second and third commands generate an HTML file; this file can be used to generate a PDF from the browser (e.g., Safari: File > Export as PDF). The other options may need additional *kwargs* to yield the intended product. 

```
julia> list_out_formats()
julia> weave("*.jmd", fig_path="figures", fig_ext=".svg", doctype="pandoc2html", pandoc_options=["--toc", "-N"]) # HTML file
```
## Session information

```{julia;term=true}
using InteractiveUtils
versioninfo()
```
